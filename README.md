# streaming_service_recsys
Проект посвящен разработке рекомендательной системы для стримингового сервиса

# Введение
Стартап в онлайн-стриминге аудиоконтента (подкасты, аудиокниги, музыка) стремится увеличить вовлечённость пользователей за счёт персонализированных рекомендаций. В наличии:

- Данные об историях прослушиваний (Last.fm) и оценках фильмов (MovieLens 25M).

- Метаданные контента (жанры, даты релизов, описания).

# Цели проекта:

1. Провести детальный анализ поведения пользователей.

2. Реализовать и сравнить несколько подходов к рекомендациям.

3. Выработать метрики качества и протестировать на отложенной выборке.

4. Разработать стратегию «холодного старта» для новых пользователей и контента.

# Структура проекта
- **eda.ipynb** - Этот Jupyter-ноутбук предназначен для проведения разведочного анализа данных (EDA) набора данных, связанного с фильмами, их рейтингами, жанрами и тегами.Представляет собой полное исследование данных о фильмах, включая загрузку, анализ и визуализацию ключевых аспектов (рейтинги, жанры, теги). Он даёт базовые статистические характеристики, визуальные представления распределений и конкретные примеры (например, топ-20 фильмов).


- **collad_filtering.ipynb** - Посвящен реализации, для начала, небольшого EDA по фильмам в дополнение к основному EDA **eda.ipynb**. Далее в рамках обработки данных и нескольких функций реализована модель коллаборативной фильтрации, позволяющая рекомендовать фильмы на основе:

  1. movieId — рекомендация на основе схожести фильма (алгоритм k-ближайших соседей)
  2. userId — рекомендация на основе пользовательского опыта (тот же алгоритм)


- **recsys_movies_matvey.ipynb** - представляет собой реализацию и сравнение трёх различных подходов (коллаборативной фильтрации (ALS), контентной фильтрации (жанры) и гибридного подхода (DSSM)) к построению систем рекомендаций для фильмов. А также анализ их производительности с помощью стандартных метрик.

## **eda.ipynb**
Этот файл представляет исследовательский анализ данных (EDA) набора данных для рекомендаций фильмов, вероятно, MovieLens, с акцентом на пользовательские оценки, метаданные фильмов, теги и показатели релевантности тегов.

## Набор данных
Набор данных состоит из пяти CSV-файлов:
- **ratings.csv**: 25,000,095 пользовательских оценок (`userId`, `movieId`, `rating`, `timestamp`).
- **movies.csv**: 62,423 фильма (`movieId`, `title`, `genres`).
- **tags.csv**: 1,093,360 пользовательских тегов (`userId`, `movieId`, `tag`, `timestamp`).
- **genome-tags.csv**: 1,128 определений тегов (`tagId`, `tag`).
- **genome-scores.csv**: 15,584,448 показателей релевантности тегов (`movieId`, `tagId`, `relevance`).

### Ключевые статистики
- **Пользователи**: 162,541 уникальных пользователей.
- **Фильмы**: 59,047 уникальных фильмов.
- **Оценки**: 25M+ оценок, с разреженной матрицей оценок (плотность: 0.26%).
- **Жанры**: 20 уникальных жанров.

## Анализ
1. **Распределение релевантности тегов**:
   - Диаграмма размаха показывает, что средняя релевантность тегов для большинства фильмов находится в диапазоне от 0.04 до 0.13 (медиана ~0.12), что указывает на обобщенную систему тегов с низкой специфичностью.
2. **Топ фильмов по релевантности тегов**:
   - Список топ-20 фильмов по средней релевантности тегов, например, *Passchendaele* (0.338), *Fight Club* (0.243), *The Matrix* (0.241), *Parasite* (0.233).
   - Жанры разнообразны, без явного жанрового уклона.

## Визуализации
- **Диаграмма размаха**: Визуализирует распределение средней релевантности тегов на фильм.
- Дополнительные графики (например, распределение оценок) могут присутствовать в полном ноутбуке.


## **collab_filtering.ipynb**

Этот Jupyter notebook реализует систему рекомендаций фильмов с использованием метода коллаборативной фильтрации. В основе системы лежит **алгоритм ближайших соседей (Nearest Neighbors)** из библиотеки scikit-learn, который используется для поиска похожих фильмов на основе оценок пользователей. Notebook демонстрирует как загрузку и анализ данных, так и реализацию двух ключевых функций: поиска похожих фильмов и рекомендаций для конкретного пользователя.

Работа в notebook разделена на несколько этапов:

1. Загрузка и исследование данных
2. Поиск похожих фильмов
   1. Матрица X транспонируется (из формата "пользователь-фильм" в "фильм-пользователь").
   2. Извлекается вектор оценок для заданного фильма.
   3. Используется NearestNeighbors с алгоритмом "brute" для поиска k+1 ближайших соседей (включая сам фильм).
   4. Первый элемент (сам фильм) исключается, возвращаются идентификаторы k похожих фильмов.
3. Рекомендации для пользователя
    1. Извлекаются оценки пользователя из матрицы user_item.
    2. Определяются фильмы, которые пользователь оценил выше порога (>= threshold).
    3. Собирается множество всех просмотренных фильмов (оценка > 0) для исключения их из рекомендаций.
    4. Для каждого понравившегося фильма вызывается find_similar_movies для поиска похожих фильмов.
    5. Похожие фильмы агрегируются, подсчитывается частота их появления.
    6. Фильмы сортируются по частоте и возвращаются топ-n_recommendations фильмов, которые пользователь ещё не видел.

## **recsys_movies_matvey.ipynb**

Ноутбук "recsys_movies_matvey.ipynb" представляет собой комплексное исследование систем рекомендаций. Он включает:

1. Загрузку и анализ данных MovieLens 25M.
2. Реализацию трёх методов: коллаборативной фильтрации (ALS), контентной фильтрации (жанры) и гибридного подхода (DSSM).
3. Сравнение их производительности с помощью стандартных метрик.

Работа поделена на этапы:

1. Загрузка данных и исследовательский анализ данных (EDA)
    1. Проверка пропущенных значений в каждом наборе данных.
    2. Анализ распределения рейтингов (например, среднее, медиана).
    3. Подсчёт уникальных пользователей, оценённых фильмов и фильмов с тегами.
    4. Вывод топ-10 самых популярных фильмов по количеству оценок.
    5. Анализ временного диапазона рейтингов и тегов (от минимальной до максимальной даты).
2. Предобработка данных
    1. Разделение на train/test (leave_one_out_split)
    2. Создание словарей пользователь-фильм (build_user_movie_sets)
3. Коллаборативная фильтрация с ALS (Matrix Factorization)
   1. **Инициализация**: Устанавливаются параметры: 64 фактора, регуляризация 0.05, 15 итераций, alpha 40.0.
   2. **Преобразование данных**: Рейтинги конвертируются в веса уверенности по формуле $ c_{ui} = 1 + \alpha \cdot r_{ui} $.
   3. **Обучение**: Используется библиотека implicit. Создаётся разреженная матрица взаимодействий (user-item), и модель ALS обучается на транспонированной матрице.
   4. **Рекомендации**: Для заданного пользователя вычисляются предсказанные рейтинги для всех фильмов, исключаются просмотренные фильмы, возвращаются топ-k рекомендаций.
4. Контентная фильтрация по жанрам
   1. **Парсинг жанров** (parse_movie_genres)
   2. **Функция content_recommend**. Рекомендации основаны на схожести контента: $ \hat{r}_{ui} = \max_{j \in I_u} \rho(e_i, e_j) \cdot r_{uj} $, где $ \rho $ — мера схожести (здесь — пересечение жанров)
5. Гибридный подход с DSSM
   1. **Класс _PairDataset** - Генерирует тренировочные пары: пользователь, позитивный фильм (оценённый), негативные фильмы (не оценённые, в соотношении 4:1).
   2. **Класс DSSMRecommender** - DSSM отображает пользователей и фильмы в общее латентное пространство:
$$\text{sim}(y_q, y_d) = \cos(y(q), y(d)) = \frac{y_q^T y_d}{\|y_q\| \cdot \|y_d\|}$$

Потеря: $ \mathcal{L} = -\log P(d^+ \mid q) $, где негативные примеры сэмплируются для эффективности.

Гибридный подход решает проблемы "холодного старта" и "фильтрационного пузыря", объединяя информацию о взаимодействиях и контенте.
6. Оценка моделей
   1. **Разделение данных**: Выполняется leave_one_out_split
   2. **Создание наборов**: Формируются словари train_user_movies и test_user_movies
   3. **Оценка** - Для каждой модели вызывается evaluate_model с функцией рекомендаций и тестовыми данными.
Метрики: precision@10, recall@10, MAP@10, NDCG@10


# Заключение

1. **Анализ данных**: Проведён качественный анализ датасета MovieLens 25M, который выявил ключевые характеристики данных, включая их объём, временной диапазон и распределение рейтингов.
2. **Модели**: Разработаны и обучены три модели рекомендаций: ALS (коллаборативная), контентная (по жанрам) и гибридная (DSSM). Каждая модель имеет свои сильные и слабые стороны, что делает их подходящими для разных сценариев.
3. **Метрики**: Реализованы стандартные метрики оценки (precision@k, recall@k, MAP@k, NDCG@k), которые позволяют объективно сравнить качество рекомендаций.
4. **Холодный старт**: Контентная фильтрация и DSSM решают проблему новых пользователей, тогда как ALS требует дополнительных данных.